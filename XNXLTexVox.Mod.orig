MODULE XNXLTexVox;
IMPORT XNXLBase, XNXLAudio, XNXLGL, XNXLMath, Raster, Graphics := WMGraphics, Random, Math,Out := KernelLog; 

TYPE PT=XNXLBase.PT;
TYPE Ray = XNXLBase.Ray;
TYPE Voxel = XNXLBase.Voxel;
TYPE Name = XNXLBase.Name;
TYPE Texture = XNXLBase.Texture;
TYPE TexVox* = OBJECT(Voxel);
VAR
	img*: Raster.Image;
	fmt: Raster.Format;
	copy : Raster.Mode;
	W,H, bpr,adr: LONGINT;
	transparent*: BOOLEAN;
	texture*: Texture;

PROCEDURE & init*(n: Name);
BEGIN
	Raster.InitMode(copy,Raster.srcCopy);
	img :=Graphics.LoadImage(n, TRUE); (* img format is BGRA8888 *)
	IF img=NIL THEN 
		Out.String("unable to load image ");
		Out.String(n);
		Out.Ln;
	ELSE
		W:=img.width-1; H:=img.height-1;
		Out.String(n);
		Out.Ln;
	END;
END init;

PROCEDURE Shade (VAR ray: Ray);
VAR
	p: Raster.Pixel;
	x,y,xi,yj: LONGINT;
	X,Y, xblend, yblend,blendx,blendy: REAL;
	r,g,b,a: REAL;
	dr,dg,db:REAL;
	bb,c, lx, ly: REAL;
	i,j,nx, ny, nz: INTEGER;
	dot: REAL;
	bpdx,bpdy: REAL;
	xov,yov,zov:REAL
BEGIN
	CASE ray.face OF
			|1: nx := -1
			|2: ny := -1
			|3: nz := -1
			|4: nx := 1
			|5: ny := 1
			|6: nz := 1
		ELSE
			nx:=1
		END;
		dot := 0.3+ ABS(nx*ray.dxyz.x + ny*ray.dxyz.y+ nz*ray.dxyz.z)*0.7; 
		CASE ray.face OF
			1: lx := ray.lxyz.y; ly :=  ray.lxyz.z;
			| 2:  lx := ray.lxyz.x; ly := ray.lxyz.z;
			| 3: lx := ray.lxyz.x; ly := ray.lxyz.y;
			| 4: lx := ray.lxyz.y; ly := ray.lxyz.z;
			| 5: lx := ray.lxyz.x; ly := ray.lxyz.z;
			| 6: lx := ray.lxyz.x; ly := ray.lxyz.y;
		ELSE
		END; 
		IF img#NIL THEN	
				X:=(1-lx)*W; Y:=(ly)*H;
				xi:=ENTIER(X)MOD W; yj:=H - (ENTIER(Y) MOD H);
				Raster.Get(img,xi,yj,p,copy);
				r := ORD(p[2])/255; g := ORD(p[1])/255; b := ORD(p[0])/255; a:= ORD(p[3])/500;
				dot:=dot*a;
				dr:=r*ray.ra*dot;
				dg:=g*ray.ga*dot;
				db:=b*ray.ba*dot;
				ray.r := ray.r + dr;
				ray.g := ray.g + dg;
				ray.b := ray.b + db;
			IF transparent THEN
				ray.ra:=ray.ra-(dr);
				ray.ga:=ray.ga-(dg);
				ray.ba:=ray.ba-(db);
				IF (ray.ra<0.1)&(ray.ga<0.1)&(ray.ba<0.1) THEN ray.terminate:=TRUE END;
				IF a>0.8 THEN  ray.terminate:=TRUE END;
			ELSE
				ray.terminate:=TRUE;
			END	
		END	
END Shade;

PROCEDURE play*();
BEGIN
	XNXLAudio.LoadWav("grollard.wav");
	XNXLAudio.Play
END play;
END TexVox;

TYPE TexMirVox* = OBJECT(Voxel);
VAR
	img*: Raster.Image;
	fmt: Raster.Format;
	copy : Raster.Mode;
	W,H, bpr,adr: LONGINT;
	transparent*: BOOLEAN;
	texture*: Texture;
	mirrorfraction*:REAL; 
	
PROCEDURE & init*(n: Name);
BEGIN
	Raster.InitMode(copy,Raster.srcCopy);
	img :=Graphics.LoadImage(n, TRUE); (* img format is BGRA8888 *)
	IF img=NIL THEN 
		Out.String("unable to load image ");
		Out.String(n);
		Out.Ln;
	ELSE
		W:=img.width-1; H:=img.height-1;
		Out.String(n);
		Out.Ln;
	END;
	mirrorfraction:=0.2;
END init;

PROCEDURE Shade (VAR ray: Ray);
VAR
	p: Raster.Pixel;
	x,y,xi,yj: LONGINT;
	X,Y, xblend, yblend,blendx,blendy: REAL;
	r,g,b,a: REAL;
	dr,dg,db:REAL;
	bb,c, lx, ly: REAL;
	i,j,nx, ny, nz: INTEGER;
	dot: REAL;
	bpdx,bpdy: REAL;
	xov,yov,zov:REAL
BEGIN
	CASE ray.face OF
			|1: nx := -1
			|2: ny := -1
			|3: nz := -1
			|4: nx := 1
			|5: ny := 1
			|6: nz := 1
		ELSE
			nx:=1
		END;
		dot := 0.3+ ABS(nx*ray.dxyz.x + ny*ray.dxyz.y+ nz*ray.dxyz.z)*0.7; 
		CASE ray.face OF
			1: lx := ray.lxyz.y; ly :=  ray.lxyz.z;
			| 2:  lx := ray.lxyz.x; ly := ray.lxyz.z;
			| 3: lx := ray.lxyz.x; ly := ray.lxyz.y;
			| 4: lx := ray.lxyz.y; ly := ray.lxyz.z;
			| 5: lx := ray.lxyz.x; ly := ray.lxyz.z;
			| 6: lx := ray.lxyz.x; ly := ray.lxyz.y;
		ELSE
		END; 
		IF img#NIL THEN	
			X:=(1-lx)*W; Y:=(ly)*H;
			xi:=ENTIER(X)MOD W; yj:=H - (ENTIER(Y) MOD H);
			Raster.Get(img,xi,yj,p,copy);
			r := ORD(p[2])/255; g := ORD(p[1])/255; b := ORD(p[0])/255; a:= ORD(p[3])/255;
			dot:=dot*a;
			dr:=r*ray.ra*dot*mirrorfraction;
			dg:=g*ray.ga*dot*mirrorfraction;
			db:=b*ray.ba*dot*mirrorfraction;
			ray.r := ray.r + dr;
			ray.g := ray.g + dg;
			ray.b := ray.b + db;
			ray.ra:=ray.ra - dr-mirrorfraction;
			ray.ga:=ray.ga-dg-mirrorfraction;
			ray.ba:=ray.ba-db-mirrorfraction;
			
			mirror(ray)
		END						
END Shade;

PROCEDURE reflect(VAR p: PT; n: PT);
VAR 
	a,b,c,dot: REAL;
BEGIN
	dot := p.x*n.x+p.y*n.y+p.z*n.z;
	a := 2*n.x*dot; b := 2*n.y*dot; c := 2*n.z*dot;
	p.x := p.x-a; p.y := p.y-b; p.z := p.z-c;
END reflect;

PROCEDURE mirror(VAR ray: Ray);
BEGIN
	reflect(ray.dxyz, ray.normal);	
	IF ray.dxyz.x < 0 THEN ray.di := FALSE  ELSE ray.di := TRUE END; 
	IF ray.dxyz.y < 0 THEN ray.dj := FALSE  ELSE ray.dj := TRUE END;
	IF ray.dxyz.z < 0 THEN ray.dk := FALSE  ELSE ray.dk := TRUE END;	
	ray.changed := TRUE;
	ray.mirrortf:=TRUE
END mirror;
END TexMirVox;

END XNXLTexVox.